"""
.. module:: HIT
   :platform: Unix, Mac
   :synopsis: The HIT object comprised of a Tasks' questions

The HIT object is generated by a task. The task maintains a pool of questions, and uses a
specific method to organize the questions into HITs.

    .. note::
        When a worker accepts a HIT on Amazon Mechanical Turk, it becomes an :ref:`Assignment<assignment>`

.. moduleauthor:: Michael Romero <michaelrom@zillowgroup.com>
"""
import json
import logging
import uuid

from jinja2 import Environment, FileSystemLoader
from opencrowd.model.database import Database
from opencrowd.config.opencrowd import BASE_DIR, TEMPLATES_DIR, HIT_HEADER, QUESTION_HEADER, SECTION_HEADER
from opencrowd.config.redis import DB_HOST, DB_PORT
from opencrowd.model.base.assignment import Assignment
from opencrowd.model.base.node import OpencrowdNode
from opencrowd.model.worker import Manager, Worker

HIT_logger = logging.getLogger('HIT')

class HIT(OpencrowdNode):
    """
    HITs are generated by Tasks.

    :param assignments_per_hit: Maximum amount of workers that can work on this HIT
    :param AutoApprovalDelayInSeconds: Amount of time until Amazon auto-approves this HIT
    :param lifetime_in_seconds: How long this HIT will appear on Amazon
    :param assignment_duration_in_seconds: How long the worker will have to complete the assignment
    :param Reward: How much to pay the worker if the Assignment is accepted
    :param Title: Title of the HIT, will be displayed on the search results page for Amazon Mechanical Turk
    :param Keywords: Keywords of the HIT. When the worker searches for these specific words, this HIT will display in the search results page for Amazon Mechanical Turk
    :param Description: Description of the HIT. Displays when worker searches.
    :param task_id: Task ID this HIT was generated from. Useful for database reasons.
    """

    def __init__(self,
                 assignments_per_hit=None,
                 AutoApprovalDelayInSeconds=604800,  # one week
                 lifetime_in_seconds=604800,
                 assignment_duration_in_seconds=1800,  # 30 minutes
                 Reward=None,
                 Title=None,
                 Keywords=None,
                 Description=None,
                 task_id=None):
        #self.questions = []
        super(HIT, self).__init__()
        self.question_ids = []
        self.instruction_ids = []

        self.opencrowd_id = str(uuid.uuid4())
        self.assignments_per_hit = assignments_per_hit
        self.lifetime_in_seconds = lifetime_in_seconds
        self.assignment_duration_in_seconds = assignment_duration_in_seconds
        self.title = Title
        self.keywords = Keywords
        self.description = Description
        self.task_id = task_id

        # set on HIT creation
        self.HITId = None
        self.HITTypeId = None
        self.HITGroupId = None
        self.HITLayoutId = None
        self.CreationTime = None
        self.Title = Title
        self.Description = Description
        self.Question = None
        self.Keywords = Keywords
        self.HITStatus = None
        self.MaxAssignments = None
        self.Reward = Reward
        self.AutoApprovalDelayInSeconds = AutoApprovalDelayInSeconds
        self.Expiration = None
        self.AssignmentDurationInSeconds = None
        self.RequesterAnnotation = None
        self.QualificationRequirements = None
        self.HITReviewStatus = None
        self.NumberOfAssignmentsPending = None
        self.NumberOfAssignmentsAvailable = None
        self.NumberOfAssignmentsCompleted = None

        self.assignment_ids = []

        self.option_ids = []

    def add_question(self, question):
        """
        Add a Question to this HIT

        :param question: Question object to add
        :type question: Question
        """
        self.question_ids.append(question.opencrowd_id)
        self.save()

    def __get_questions(self):
        """
        Convert question ids in self to question objects

        :return: list of Question objects
        :rtype: list[Question]
        """
        database = Database(DB_HOST, DB_PORT)
        return [database.get(QUESTION_HEADER + question_id) for question_id in self.question_ids]

    def render(self, form_submission_action='https://workersandbox.mturk.com/mturk/externalSubmit'):
        env = Environment(trim_blocks=True, lstrip_blocks=True, extensions=['jinja2.ext.do'])
        env.loader = FileSystemLoader(TEMPLATES_DIR + 'base')
        template = env.get_template('HIT.html')
        self.questions = self.__get_questions()
        with open(BASE_DIR + "/render.html", "w+") as f:
            f.write(template.render(HIT=self, jinja_form_action=form_submission_action))
        try:
            render = template.render(HIT=self, jinja_form_action=form_submission_action)
        except Exception as e:
            HIT_logger.error("Unable to get opencrowd question {}. An exception of type {} occurred. Arguments:\n{!r}".format(type(e).__name__, e.args))
        return render

    def update(self, generated_crowdsource, database=None):
        database = database if database is not None else Database(DB_HOST, DB_PORT)
        try:
            assignments = generated_crowdsource.list_assignments_for_hit(self.HITId)
            for assignment in assignments:
                new_assignment = Assignment(assignment)
                if new_assignment.AssignmentId not in self.assignment_ids:
                    self.assignment_ids.append(new_assignment.AssignmentId)
                    Manager.process_assignment(new_assignment)
                self.save()
                HIT_logger.info("Assignment found: {}".format(new_assignment.AssignmentId))

        except Exception as e:
            print e.message
            exit(1)

    def submit(self, AMT):
        """
        Submit self through the AMT connection and update self with the results
        :param AMT: The open AMT connection object
        :return:
        """
        response = AMT.push(self)
        database = Database(DB_HOST, DB_PORT)
        database.delete(HIT_HEADER + self.opencrowd_id)
        for key in response['HIT']:
            setattr(self, key, (response['HIT'][key]))

        setattr(self, 'CreationTime', str(self.CreationTime))
        setattr(self, 'Expiration', str(self.Expiration))
        setattr(self, 'opencrowd_id', str(self.HITId))
        setattr(self, 'HITId', str(self.HITId))
        self.save()
        return self

    def __generate_javascript_variable(self):
        javascript_variables = []
        questions = []
        database = Database(DB_HOST, DB_PORT)

        for question_id in self.question_ids:
            questions.append(database.get(QUESTION_HEADER + question_id))
        for question in questions:
            javascript_variable = {}
            for section in question.sections:
                if section.get_name() not in javascript_variable:
                    javascript_variable[section.get_name()] = []
                javascript_variable[section.get_name()].append(section.to_json())
                # print "Section: " + section.get_name() + " : " + json.dumps(section.to_json(), indent=4)
            javascript_variables.append(javascript_variable)
        return json.dumps(javascript_variables, indent=4)

    def generate_dags(self):
        database = Database(DB_HOST, DB_PORT)
        dags = []
        for question in self.questions:
            dag = {}
            for section in question.sections:
                dag[section.opencrowd_id] = section.to_json()
                if section.parents == "root":
                    dag["root"] = section.opencrowd_id
                dag['question_id'] = question.opencrowd_id
                if section.to_json()['type'] == "InputGroup":
                    for option_id in section.option_ids:
                        option = database.get(SECTION_HEADER + option_id)
                        dag[option.opencrowd_id] = option.to_json()
            dags.append(dag)
        return json.dumps(dags, indent=4)

    def generate_order_of_questions(self):
        question_orders = []
        questions = self.__get_questions()
        for question in questions:
            question_order = []
            for section in question.sections:
                question_order.append(section.to_json())
            question_orders.append(question_order)
        return json.dumps(question_orders, indent=4)

    def save(self):
        HIT_logger.debug("Saving HIT {}".format(self.opencrowd_id))
        database = Database(DB_HOST, DB_PORT)
        database.set(HIT_HEADER + self.opencrowd_id, self)


if __name__ == '__main__':
    from opencrowd.model.base import Question
    from opencrowd.model.section import TextBox, Image
    text_box = TextBox(main_title='Title', text=['Paragraph 1', 'Paragraph 2'])
    image = Image(urls=['http://lorempixel.com/400/200/nature/'])

    question = Question()
    question.add_section(image)
    question.add_section(text_box)

    hit = HIT()
    hit.add_question(question)

    print hit.render()
